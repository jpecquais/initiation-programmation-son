<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Initiation à la programmation</title>
    <meta charset="utf-8" />
    <meta name="author" content="Jean-Loup Pecquais" />
    <script src="libs/header-attrs-2.11/header-attrs.js"></script>
    <link href="libs/remark-css-0.0.1/default.css" rel="stylesheet" />
    <link href="libs/remark-css-0.0.1/default-fonts.css" rel="stylesheet" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

# Initiation à la programmation
## Et son application aux métiers du son
### Jean-Loup Pecquais

---


class: middle, center

# Programme

---

## Jours 1

+ Rappels sur l'informatique orienté audio
+ Historique de la programmation
+ Les environnements de developpement
+ Les méthodes de travail

--

## Jours 2

+ Introduction au language lua
+ Découverte de l'API de ReaScript
+ TP : Création de scripts

--

## Jours 3

+ Introduction au language de programmation EEL2
+ Présentation du framework JSFX
+ TP : Créer un plug-in audio

---

# Objectifs

+ Découvrir le monde de la programmation
+ Ajouter la programmation dans sa boîte à outil d'ingénieur du son
+ Comprendre les tenants et les aboutissant de la création d'un plug-in audio

---

# Contact

+ Jean-Loup Pecquais
+ jeanlouppecquais@ik.me

---

class: middle, center

# Préambule

---

## Pourquoi s'intéresser à la programmation ?

--

+ Comprendre le fonctionnement de ses outils

--

+ Pouvoir adapter et/ou construire ses outils

--

+ Mieux investir son temps et son argent

---

class: middle, center

# Généralités

???

+ Qu'est ce qu'un ordinateur ?
+ Qu'est ce qu'un language de programmation ?

---

## Les ordinateurs

+ Ensemble de composants : Processeurs + Mémoires
    + Processeurs : CPU (plusieurs coeurs ou plusieurs CPU), GPU
    + Mémoire de stockage, mémoire vive, etc.

+ Ensemble de logiciels
    + Kernel
    + Gestion des périphériques (audio, vidéo, contrôleurs)
    + Interfaces graphiques (bureau, explorateur de fichiers)

---

## Les systèmes d'exploitations

.pull-left[

**Solutions propriétaires**

&lt;img src="images/windows.jpg" width="10%" /&gt;&lt;img src="images/macos.png" width="10%" /&gt;


+ Windows (Microsoft)
+ MacOS (Apple)

    
]

.pull-right[

**Solutions libres**

&lt;img src="images/linux.png" width="10%" style="display: block; margin: auto;" /&gt;

+ Linux/GNU (Libre et gratuit)

]

--

**Choisir son OS ?**

--

+ MacOS : Linux clef en main

--

+ Linux : MacOS en kit

--

+ Windows : ?

---

## Informatique embarquée / informatique généraliste

.pull-left[

Informatique embarquée
+ Optimisé pour une tâche (exemple : console de mixage numérique)

]

.pull-right[

Informatique de "bureau"
+ Polyvalente mais non spécifique

]

On peut également évoquer l'informatique destinée aux serveurs.

---

## Les défis de l'audio-numérique sur ordinateur générique

+ Le traitement de l'audio en temps réel !
--

    + Equipement non dédié (donc non optimisé)
--
    + Tous les kernels ne sont pas égaux.
--
    + Toutes les bus de communication ne se vallent pas (USB vs PCIe par ex.)
--
    + Tous les pilotes d'interfaces audio non plus.
--
    + Ainsi que les logiciels ( Pro Tools &amp; REAPER par ex. ;-) ) 

???

Kernels : "noyau" // Générique VS low-latency VS real-time // différences de scheduler et de gestion des priorités. // FIFO - LILO - FILO etc.

---

## Les défis du développement orienté audio

Au delà de la qualité sonore d'un plug-in

+ Optimiser la charge CPU
+ Prendre le minimum de temps possible

Dans les deux cas, la question est souvent : à quel prix sur le rendu audio ?

---

### Exemple concret : égaliseur

.pull-left[

**ReaEQ (Cockos)**

&lt;img src="images/reaeq.jpg" width="85%" style="display: block; margin: auto;" /&gt;

+ **temps réel**
+ Cramping vers la fréquence de Nyquist.


]

.pull-right[

**Pro-Q3 (Fab Filter)** :

&lt;img src="images/proq3.jpg" width="85%" style="display: block; margin: auto;" /&gt;

+ *zéro latence* : **temps réel**, sans cramping. Déphasage du filtre se réplie à Nyquist.
+ *natural phase* : **320 smpl** de latence, plus de cramping
+ *phase linéaire* : de **3072 smpl** à **66560 smpl**, inutilisable pour du temps réel.


]



---

### Exemple concret : compresseur

.pull-left[

**ReaComp (Cockos)**

&lt;img src="images/reacomp.png" width="80%" style="display: block; margin: auto;" /&gt;

+ **Temps réel**
+ **Repliement spectral** (aliasing) lorsque les temps d'attaque et de relâchement sont court.

]

.pull-right[

**Molotok (Tokyo Dawn Lab)**

&lt;img src="images/molotok.jpg" width="85%" style="display: block; margin: auto;" /&gt;

+ Plusieurs modes permettant d'ajuster le ratio latence/performance audio.
+ **"Alias"** en mode **temps réel**.
+ Les modes *éco* et *precise* utilisent certainement du sur-échantillonnage pour réduire le repliement spectral.

]

---

### Exemple concret : saturation

.pull-left[

**Saturation (LOSER)**

&lt;img src="images/saturation.png" width="85%" style="display: block; margin: auto;" /&gt;

+ temps réel
+ Forte présence d'alisaing
+ Léger en ressource.

]

.pull-right[

**ChowTapeModel (ChowDSP)**

&lt;img src="images/chowtapemodel.png" width="70%" style="display: block; margin: auto;" /&gt;

+ Latence de 36 smpl par défaut.
+ Jusqu'à 102 smpl de latence à OS*16 en phase linéaire.
+ Très gourmand en ressource, mais rendu "qualitatif".

]


---

## Les qualités d'un plug-in

+ Chercher le meilleur rapport entre performance et qualité de rendu sonore
+ Stabilité sur les différents formats (VST, VST3, AAX, AU, LV2, etc.)
+ **Et l'interface utilisateur !**

---

class: middle, center

# La programmation et ses langages

---

## Que signifie "programmer"

+ Donner des instructions au processeur.
+ Pour cela on utilise un langage.
+ L'utilisation d'un langage plutôt qu'un autre viendra définir un équilibre entre performance, fonctionnalités, et facilité de développement.

---

## Les différents types de languages

Du niveau le plus bas au plus haut (du plus proche de la machine au plus proche de l'utilisateur)

--

+ Le language assembleur

--

+ Les languages compilés

--

+ Les languages interprétés

---

## Hello world en assembleur !

En assembleur :

~~~
str:
 .ascii "Hello World!\n"
 .global _start

_start:
movl $4, %eax
movl $1, %ebx
movl $str, %ecx
movl $8, %edx
int $0x80
movl $1, %eax
movl $0, %ebx
int $0x80

;Compilation:
;as code.s -o code.o
;ld code.o -o code

;Execution:
;./code
~~~

---


## Hello world en C++ !

En C++ :

~~~
#include &lt;iostream&gt;
using namespace std;
int main() {
   cout &lt;&lt; "Hello World!" &lt;&lt; endl; // This prints Hello, World!
   return 0;
}
~~~

---

## Hello world en lua !

~~~
print("Hello World!")
~~~

---

### Les langages compilés vs langages interprétés

.pull-left[

&lt;img src="images/compiler.png" width="40%" style="display: block; margin: auto;" /&gt;

]

.pull-right[

&lt;img src="images/interpreter.png" width="40%" style="display: block; margin: auto;" /&gt;

]

???

Démonstration de la compilation et de l'utilisation d'un logiciel

---

## Langages à "connaître"

--

Le **C** (1972), développé par par Dennis Ritchie et Kenneth Thompson, aux laboratoires Bell.

--

+ C++ (1983, représente la majorité des applications informatiques)
+ Lua (REAPER, TouchOSC)
+ JavaScript (MaxMSP, Open Stage Control, Chataîgne)
+ Faust (Développement DSP facilité)
+ Python (Boîte a outil extrêmement complète, alternative à Mathlab)

--

En sus :
+ Markdown (prise de note, création de document)
+ Rmarkdown (alternative à LaTeK)

???

Connaître dans le sens : connaître son existance. Il ne s'agit pas d'apprendre tout ces langages.

---

class: middle, center

# Les outils de développement

---

class: middle, center

## Les IDE

---

### Qu'est ce qu'un IDE ?

--

* Environnement de développement intégré

--

* Regroupe un ensemble de fonctionnalités :

--

    * Un éditeur de texte
    * Une aide à l'écriture (auto-complétion)
    * Un terminal
    * Un compileur / un interpréteur
    * Un gestionnaire de projet

--

**Quelques exemples**

--

.pull-left[

* Les classiques
    * Visual Studio
    * X-Code
    * CodeBlock
    
]

--

.pull-right[

* Les plus "modernes"
    * Visual Studio Code
    * Sublime text
    * PyCharm/Clion/JetBrain

]

---

class: middle, center

## Les frameworks

---

### Le principe

--

* Proposer un socle de fonctionnalités de base :
    * Accesseur audio, une librairie graphique, blocs DSP élémentaires, etc.

--

**Quelques exemples**

--

.pull-left[

**JUCE**

* Utilisé par la grande majorité des plug-ins du marché
* Appartient à PACE
* Soutenu par une grande communauté

]

--

.pull-right[

**FLUX:: Framework**

* Très complet et très puissant
* Réservé à la société FLUX::
* Très peu d'utilisation en dehors des produits FLUX::

]

--

**Waves**, **UAD**, **MeldaProduction**, sont des exemples de marques utilisant leur **propre** framework.

---

class: middle, center

## Les SDK

---

### Présentation

* SDK signifie : Software Development Kit
* Outil délivré à des développeurs par des développeurs pour des développeurs
* Exemple : SDK VST3 de Steinberg

&lt;!-- * SDK signifie : Software Development Kit --&gt;

---

class: middle, center

## Les API

---

### Présentation

* API signifie : Application Programming Interface
* Ensemble de classes, méthodes, fonctions et variable
* Permet à deux logiciels de s'interfacer

--

**Exemples**

L'API ReaScript de REAPER
L'API Javascript de MaxMSP

---

class: middle, center

# Les logiciels de gestion de version

---

## Travail colaboratif

* Le développement est un travail d'équipe
    * Architècte logiciel
    * Implémentation bas niveau, framework
    * Implémentation DSP
    * Implémentation graphique
    * etc.
* Plusieurs personnes peuvent être amenées à manipuler les mêmes fichiers
* Certaines modifications peuvent casser le programme, comment revenir en arrière ?


---

## Git


.pull-left[
* Créé par Linus Torvald
* Open-source 
* Logiciel de gestion de version le plus utilisé au monde.
]

--

.pull-right[
&lt;img src="images/git.png" width="40%" style="display: block; margin: auto;" /&gt;
]

--

**Solutions utilisant Git**

--

.pull-left[
* GitHub
* GitLab
* BitBucket
* NPM
]

.pull-right[
&lt;img src="images/github.png" width="40%" style="display: block; margin: auto;" /&gt;
]


---

### Comment fonctionne Git

&lt;img src="images/git-schematic.png" width="70%" style="display: block; margin: auto;" /&gt;

---

### Un peu de jargon (1/2)

.pull-left[
~~~
clone
~~~
]

.pull-right[
Permet de "cloner", télécharger un dépôt (repository)
]

--

.pull-left[
~~~
fork
~~~
]

.pull-right[
Permet de copier un dépôt existant afin de le modifier sans affecter le dépôt initial.
]

--

.pull-left[
~~~
branche
~~~
]

.pull-right[
Dans la philosophie git, chaque fonctionnalité d'un projet est developpé sur une branche à part. La branche principale, souvent appelée master, devrait toujours un projet en état fonctionnel.
]

--

.pull-left[
~~~
commit
~~~
]

.pull-right[
Valider son travail sur le dépôt local. Est toujours associé à une description.
]

---


### Un peu de jargon (2/2)

.pull-left[
~~~
push
~~~
]

.pull-right[
Met à jours le dépôt distant à partir du dépôt local. (upload le dernier commit)
]

--

.pull-left[
~~~
pull
~~~
]

.pull-right[
Met à jours le dépôt local à partir du dépôt distant. (télécharge le ou les derniers commit)
]

--

.pull-left[
~~~
pull request
~~~
]

.pull-right[
Demande la permission d'appliquer les modifications d'une branche de developpement sur la branche principale
]

--

.pull-left[
~~~
merge
~~~
]

.pull-right[
Fusionne une branche dans une autre
]

---

class: middle, center

# TP : Configuration d'un environnement de travail

---

## A faire

+ Installer Visual Studio Code
+ Installer Git
+ Créer un compte sur GitHub
+ "Forker" le repository suivant :

&lt;code&gt;github.com/mon/repository/ENSLL&lt;/code&gt;

---

class: middle, center

# Introduction au langage lua

---

## Généralités

.pull-left[
+ Créé en 1993, au Brésil
+ Luiz Henrique de Figueiredo, Roberto Ierusalimschy et Waldemar Celes
+ Conçu afin d'être embarqué au sein d'une autre application
+ Interpréteur en C, donc largement compatible
]

.pull-right[
&lt;img src="images/lua.png" width="25%" style="display: block; margin: auto;" /&gt;
]

Très populaire dans le développement de jeux vidéos. Utilisé également dans le réseau et dans l'informatique embarquée.

On le retrouve aussi dans les logiciels **REAPER** et **TouchOSC** dans le monde de l'audio.

---

## Les variables

Pour déclarer une variable, il suffit de lui donner un nom et une valeur.


```lua
foo = 3 --créer une variable, nommée "foo", stockant le nombre 3
```

Un ensemble de charactères précédés par "--" est considéré comme un commentaire.

La bonne pratique consiste à toujours précéder la déclaration d'une variable par le mot clef "local". Cela permet de limiter la zone de définition de la variable.


```lua
local foo = 3
```

---

## Les types de variables


```lua
local myNumber  = 3                --cette variable est un nombre
local myString  = "Hello, World!"  --cette variable est une chaine de charactère (string)
local myBool    = true             --cette variable est un booléen
local myNil     = nil              --cette variable ne possède aucune valeur
```

Le typage en lua est extrêmement faible. Une variable peut changer de type a n'importe quel moment, sans contraintes.


```lua
local myNumber  = 3                --cette variable est un nombre
myNumber        = "Hello, World!"  --est-ce bien pertinent ?
```
---

## Les opérations


```lua
local a  = 3+2                      --addition
local b  = 5-7                      --soustraction
local c  = 2*5                      --multiplication
local d  = 10/2                     --division

local e  = "Hello,".." World!"      --concaténation
```

Il est également possible d'appliquer des opérations sur des variables


```lua
local a = 2
local b = 8

local c = (a+b)/4
```

---

## Quelques fonctions


```lua
print("Hello, World!")              --Affiche la chaîne de charactères "Hello, World!" dans le terminal. Pratique pour débugger surtout dans REAPER.

local foo = tostring(3)
print(foo)                          --Affiche la chaîne de charactères "3" dans le terminal.

local bar = tonumber("3")           
print(bar)                          --Affiche le nombre 3 dans le terminal.

local myType = type(foo)            --La fonction type retourne une chaîne de charactère indiquant le type de la variable.
print(foo)                          -- Affiche la chaîne de charactères "number" dans le terminal
```

---

## Les conditions


```lua
local a = 3
local b = 2

local result = false

--Les symboles de comparaison sont == &gt;= &lt;= &gt; &lt; ~=
if a == b then
    result = true
end

print(result)
```


```lua
local a = 3
local b = 2

local myString = nil

if a &gt;= b then
    myString == "This is true"
else
    myString == "This is false"
end

print(result)
```

---




# Jours 1

## Historique de la programmation

Languages compilés VS Languages scriptés

Performance VS praticité

**copié collé**

[https://fr.wikibooks.org/wiki/Programmation/Historique](https://fr.wikibooks.org/wiki/Programmation/Historique)

[https://en.wikipedia.org/wiki/Assembly_language](https://en.wikipedia.org/wiki/Assembly_language)

[https://en.wikipedia.org/wiki/Fortran](https://en.wikipedia.org/wiki/Fortran#Obsolescence_and_deletions)

[https://simple.wikipedia.org/wiki/C_(programming_language)](https://simple.wikipedia.org/wiki/C_(programming_language))

[https://simple.wikipedia.org/wiki/Compiler](https://simple.wikipedia.org/wiki/Compiler)

[https://en.wikipedia.org/wiki/C%2B%2B](https://en.wikipedia.org/wiki/C%2B%2B)

L'arrivée de la logique programmable provoqua une cascade 
d'inventions : l'assembleur (c'est à dire l'utilisation de mnémoniques à
 la place des séquences de chiffres du langage machine) fut inventé en 
1948, le premier langage évoluée, l'A0, en 1951, suivi du [Fortran](https://fr.wikibooks.org/wiki/Programmation_Fortran) (1956), du [Cobol](https://fr.wikibooks.org/wiki/Programmation_Cobol) (1959), du [Lisp](https://fr.wikibooks.org/wiki/Programmation_Lisp) (1959) et de l'[Algol](https://fr.wikibooks.org/wiki/Programmation_Algol) (1960).

Le [Basic](https://fr.wikibooks.org/wiki/Programmation_Basic) est créé en 1965 et le [Pascal](https://fr.wikibooks.org/wiki/Programmation_Pascal) en 1968. Le [C](https://fr.wikibooks.org/wiki/Programmation_C) et [Prolog](https://fr.wikibooks.org/w/index.php?title=Programmation_Prolog&amp;action=edit&amp;redlink=1) voient le jour en 1972 et [Smalltalk](https://fr.wikibooks.org/wiki/Programmation_Smalltalk), le premier langage objet, la même année.

La programmation orientée objet prendra son essor avec [C++](https://fr.wikibooks.org/wiki/Programmation_C%2B%2B), créé en 1983. En 1986 est créé [Perl](https://fr.wikibooks.org/wiki/Programmation_Perl). [Python](https://fr.wikibooks.org/wiki/Programmation_Python) est créé en 1991 et 1995 verra l'apparition de [Java](https://fr.wikibooks.org/wiki/Programmation_Java), qui prétend être portable au niveau de l’exécutable, et de [PHP](https://fr.wikibooks.org/wiki/Programmation_PHP). 2000 voit l'apparition du premier langage créé par Microsoft, [C#](https://fr.wikibooks.org/wiki/Programmation_C_sharp).

Les [langages de description](https://fr.wikipedia.org/wiki/Langage_de_d%C3%A9finition_de_donn%C3%A9es), pas assez complets pour être considérés comme des langages de programmation, apparaissent vers 1969, avec le [GML](https://fr.wikipedia.org/wiki/Standard_Generalized_Markup_Language) puis le [SGML](https://fr.wikipedia.org/wiki/Standard_Generalized_Markup_Language).
Le [HTML](https://fr.wikibooks.org/wiki/Programmation_HTML) est créé en 1990.
En 1996 est introduit [XML](https://fr.wikibooks.org/wiki/Programmation_XML).
Ces deux derniers langages sont dérivés du SGML : leur syntaxe reprend différentes parties de celle du SGML.

Les travaux actuels semblent montrer que la tendance vers plus 
d'abstraction se poursuit, avec la programmation orientée aspect, par 
exemple.

## Les environnements de développement

IDE (VS Code?)

Framework

JUCE (juste présenter, représente 80% des PI)

FLUX:: (en contre exemple à JUCE)

SDK

API Ode à la documentation

GIT (Avec GUI)

Repo

Branche

Pull

Commit

Push

Pull Request

## Configurer le dépôt gitHub de la promo

Un repo sur mon compte, une branche par élève.

# Jours 2

## Introduction au lua

[https://www.lua.org/manual/5.4/](https://www.lua.org/manual/5.4/)

Présentation générale

- Variable
- Fonction
- Tableau
- Conditionnelles
- Boucle for

De l’importance de bien commenter

## Présentation de l’API de REAPER

- Bienvenu en Corrèze

## Scriptons !

- Gestion de la tête de lecture
- Utilitaire de création de DDP
- Créer un groupe de piste
- Faire un fader unity
- Découper un objet avec le curseur de la souris, sans déplacer la tête de lecture
- Créer une piste auxiliaire pour les pistes sélectionnées
- Créer une piste auxiliaire par pistes séléctionnées

# Jours 3

## Présentation eel2

[https://www.cockos.com/EEL2/](https://www.cockos.com/EEL2/)

Le C en sms

## Codons !

- Matrice MS
- Panoramique d’intensité
- Panoramique de temps
- Panoramique de temps et d’intensité
- Elargisseur mono/stereo (compatible mono)
- Chorus
- Flanger
- Phaser
- Rotation de phase linéaire, sans FFT
- Délai
- Compresseur (? à évaluer)
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"ratio": "16:9",
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
