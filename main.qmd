---
title: Initiation √† la programmation
subtitle: Et son application aux m√©tiers du son
author: Jean-Loup Pecquais
format:
    revealjs:
        theme: simple
        highlight-style: github
        scrollable: true
---

# Programme

## Jours 1

+ Rappels sur l'informatique d√©di√©e √† l'audio temps r√©el
+ Les environnements de d√©veloppement et les m√©thodes de travail
+ Introduction au langage lua
+ D√©couverte de l'API de ReaScript
+ TP : Cr√©ation de scripts (1/2)

## Jours 2

+ TP : Cr√©ation de scripts (2/2)
+ Pr√©sentation du langage de programmation FAUST
+ TP : Cr√©er un plug-in audio

## Jours 3

+ TP : Cr√©ation d'un compresseur
+ Cr√©ation d'un plug-in VST3 (?)

## Objectifs

+ D√©couvrir le monde de la programmation
+ Ajouter la programmation dans sa boite √† outils d'ing√©nieur du son
+ Comprendre les tenants et les aboutissants de la cr√©ation d'un plug-in audio

## Contact

+ Jean-Loup Pecquais
+ ```jeanlouppecquais@ik.me```


# Pr√©ambule

## Pourquoi s'int√©resser √† la programmation ?

:::{.incremental}
+ Comprendre le fonctionnement de ses outils
+ Pouvoir adapter et/ou construire ses outils
+ Mieux investir son temps et son argent ?
:::

# G√©n√©ralit√©s

:::{.notes}
+ Qu'est-ce qu'un ordinateur ?
+ Qu'est-ce qu'un langage de programmation ?
:::

## Les ordinateurs

+ Ensemble de composants : Processeurs + M√©moires
    + Processeurs : CPU (plusieurs c≈ìurs ou plusieurs CPU), GPU
    + M√©moire de stockage, m√©moire vive, etc.

+ Ensemble de logiciels
    + Kernel
    + Gestion des p√©riph√©riques (audio, vid√©o, contr√¥leurs)
    + Interfaces graphiques (bureau, explorateur de fichiers)

## Les syst√®mes d'exploitation

::::{.columns}

:::{.column}

**Solutions propri√©taires**

:::{layout-ncol="2"}
![](images/windows.jpg){width="50%"}

![](images/macos.png)
:::

+ Windows (Microsoft)
+ MacOS (Apple)

:::

:::{.column}

**Solutions libres**

![](images/linux.png){width="50%"}

+ Linux/GNU (Libre et gratuit)

:::

::::

---

**Choisir son OS ?**

:::{.incremental}
+ MacOS : Linux clef en main
+ Linux : MacOS en kit
+ Windows : ü§∑‚Äç‚ôÇÔ∏è
:::

---

## Informatique embarqu√©e / informatique g√©n√©raliste

::::{.columns}

:::{.column}
Informatique embarqu√©e

+ Optimis√© pour une t√¢che (exemple : console de mixage num√©rique)
:::

:::{.column}
Informatique de "bureau"

+ Polyvalente, mais non sp√©cifique
:::

::::

On peut √©galement √©voquer l'informatique destin√©e aux serveurs.

---

## Les d√©fis de l'audionum√©rique sur ordinateur g√©n√©rique

+ **Le traitement de l'audio en temps r√©el !**

    + √âquipement non d√©di√© (donc non optimis√©)
    + Tous les kernels ne sont pas √©gaux.
    + Tous les bus de communication ne se valent pas (USB vs PCIe par ex.)
    + Tous les pilotes d'interfaces audio non plus.
    + Ainsi que les logiciels ( Pro Tools & REAPER par ex. ;-) ) 

:::{.notes}
Kernels : "noyau" // G√©n√©rique VS low-latency VS real-time // diff√©rences de scheduler et de gestion des priorit√©s. // FIFO - LILO - FILO etc.
:::

## Les d√©fis du d√©veloppement orient√© audio

Au-del√† de la qualit√© sonore d'un plug-in

+ Optimiser les ressources (CPU / RAM)
+ Prendre le minimum de temps possible

Dans les deux cas, la question est souvent : √† quel prix sur le rendu sonore ?

---

### Exemple concret : √©galiseur {.smaller}

::::{.columns}

:::{.column}
**ReaEQ (Cockos)**

![](images/reaeq.jpg)

+ **temps r√©el**
+ Cramping vers la fr√©quence de Nyquist.

:::

:::{.column}
**Pro-Q3 (Fab Filter)** :

![](images/proq3.jpg)

+ *z√©ro latence* : **temps r√©el**, sans cramping. D√©phasage du filtre se replie √† Nyquist.
+ *natural phase* : **320 smpl** de latence, plus de cramping
+ *phase lin√©aire* : de **3072 smpl** √† **66560 smpl**, inutilisables pour du temps r√©el.
:::

::::

--- 

### Exemple concret : compresseur

::::{.columns}

:::{.column}
**ReaComp (Cockos)**

![](images/reacomp.png)

+ **Temps r√©el**
+ **Repliement spectral** (aliasing) lorsque les temps d'attaque et de rel√¢chement sont courts.
:::

:::{.column}
**Molotok (Tokyo Dawn Lab)**

![](images/molotok.jpg)

+ Plusieurs modes permettant d'ajuster le ratio latence/performance audio.
+ **"Alias"** en mode **temps r√©el**.
+ Les modes *√©co* et *precise* utilisent certainement du sur√©chantillonnage pour r√©duire le repliement spectral.
:::

::::

---

### Exemple concret : saturation

::::{.columns}

:::{.column}
**Saturation (LOSER)**

![](images/saturation.png)

+ temps r√©el
+ Apparition de repliement spectral (aliasing)
+ L√©ger en ressource.
:::

:::{.column}
**ChowTapeModel (ChowDSP)**

![](images/chowtapemodel.png)

+ Latence de 36 smpl par d√©faut.
+ Jusqu'√† 102 smpl de latence √† OS*16 en phase lin√©aire.
+ Tr√®s gourmand en ressource, mais rendu "qualitatif".
:::

:::::

## Les qualit√©s d'un plug-in

:::{.incremental}
+ Chercher le meilleur rapport entre performance et qualit√© de rendu sonore
+ Stabilit√© sur les diff√©rents formats (VST, VST3, AAX, AU, LV2, etc.)
+ **Et l'interface utilisateur !**
:::

# La programmation et ses langages

## Que signifie "programmer"

:::{.incremental}
+ Donner des instructions au processeur.
+ Pour cela on utilise un langage.
+ L'utilisation d'un langage plut√¥t qu'un autre viendra d√©finir un √©quilibre entre performances, fonctionnalit√©s, et facilit√© de d√©veloppement.
:::

## Les diff√©rents types de langages

Du niveau le plus bas au plus haut (du plus proche de la machine au plus proche de l'utilisateur)

:::{.incremental}
+ Le langage assembleur
+ Les langages compil√©s
+ Les langages interpr√©t√©s
:::

## Hello world en assembleur !

En assembleur :

```{assembly}
str:
 .ascii "Hello World!\n"
 .global _start

_start:
movl $4, %eax
movl $1, %ebx
movl $str, %ecx
movl $8, %edx
int $0x80
movl $1, %eax
movl $0, %ebx
int $0x80

;Compilation:
;as code.s -o code.o
;ld code.o -o code

;Execution:
;./code
```

## Hello world en C++ !

En C++ :

```{c++}
#include <iostream>
using namespace std;
int main() {
   cout << "Hello World!" << endl; // This prints Hello, World!
   return 0;
}
```

## Hello world en lua !

```{lua}
print("Hello World!")
```

---

### Les langages compil√©s vs langages interpr√©t√©s

**Language compil√©**
```{mermaid}
flowchart LR
  A(Fichiers sources) --> B(Compilateur)
  B --> C(Fichier executable)
  C --> D(Execution)
  D --> E(R√©sultat)
```

**Language compil√©**
```{mermaid}
flowchart LR
  A(Fichiers scripts) --> B(Interpr√©teur)
  B --> C(R√©sultat)
```

:::{.notes}
D√©monstration de la compilation et de l'utilisation d'un logiciel
:::

## Langages √† "conna√Ætre"

:::{.r-fit-text}
Le **C** (1972), d√©velopp√© par Dennis Ritchie et Kenneth Thompson, aux laboratoires Bell.

+ **C++** (1983, repr√©sente la majorit√© des applications informatiques)
+ **Lua** (REAPER, TouchOSC)
+ **JavaScript** (MaxMSP, Open Stage Control, Chata√Ægne)
+ **Faust** (D√©veloppement DSP facilit√©)
+ **Python** (Bo√Æte √† outils extr√™mement compl√®te, alternative √† Mathlab)
+ Pour le dsp: **Octave**, **Julia**, etc.

Autre:

+ **Java** : Android
+ **JavaScript** : Web en g√©n√©ral

En sus (m√™me si ce ne sont pas des languages de programmation):

+ **Markdown** (prise de note, cr√©ation de documents, pages web)
+ **Quarto** (alternative √† LaTeK / HTML)
:::

:::{.notes}
Conna√Ætre dans le sens : conna√Ætre son existence. Il ne s'agit pas d'apprendre tous ces langages.
:::

# Les outils de d√©veloppement

## Les IDE

### Qu'est-ce qu'un IDE ?

:::{.incremental}
+ Environnement de d√©veloppement int√©gr√©
+ Regroupe un ensemble de fonctionnalit√©s :
    * Un √©diteur de texte
    * Une aide √† l'√©criture (autocompl√©tion)
    * Un terminal
    * Un compileur / un interpr√©teur
    * Un gestionnaire de projet
:::

---

**Quelques exemples**

::::{.columns}

:::{.column}
+ Les classiques
    * Visual Studio
    * X-Code
    * CodeBlock
:::

:::{.column}
+ Les plus "modernes"
    * Visual Studio Code
    * Sublime text
    * PyCharm/Clion/JetBrain
:::

::::

## Les frameworks

### Le principe

+ Proposer un socle de fonctionnalit√©s de base :
    * Accesseur audio, une librairie graphique, blocs DSP √©l√©mentaires, etc.

**Quelques exemples**

::::{.columns}
:::{.column}
**JUCE**

+ Utilis√© par la grande majorit√© des plug-ins du march√©
+ Appartiens √† PACES
+ Soutenu par une grande communaut√©
:::

:::{.column}
**FLUX:: Framework**

+ Tr√®s complet et tr√®s puissant
+ R√©serv√© √† la soci√©t√© FLUX::
+ Tr√®s peu d'utilisation en dehors des produits FLUX::
:::
::::
**Waves**, **UAD**, **MeldaProduction**, sont des exemples de marques utilisant leur **propre** framework.

## Les SDK

### Pr√©sentation

+ SDK signifie : Software Development Kit
+ Outil d√©livr√© √† des d√©veloppeurs par des d√©veloppeurs

### Exemples

+ SDK VST3 de Steinberg
+ SDK AAX de Pro Tools


## Les API

### Pr√©sentation

+ API signifie : Application Programming Interface
+ Ensemble de classes, m√©thodes, fonctions et variable
+ Permets √† deux logiciels de s'interfacer

### Exemples

+ L'API ReaScript de REAPER
+ L'API Javascript de MaxMSP

## Les librairies

### Pr√©sentation

+ Ensemble de fonctions d√©di√©es √† une t√¢che particuli√®re

### Exemples

+ Matplotlib pour le trac√© de graphiques sous python

# Les logiciels de gestion de version

## Travail collaboratif

+ Le d√©veloppement est un travail d'√©quipe
    + Architecte logiciel
    + Impl√©mentation bas niveau, framework
    + Impl√©mentation DSP
    + Impl√©mentation graphique
    + etc.
+ Plusieurs personnes peuvent √™tre amen√©es √† manipuler les m√™mes fichiers
+ Certaines modifications peuvent casser le programme, comment revenir en arri√®re ?

## Git

::::{.columns}
:::{.column}
+ Cr√©√© par Linus Torvald
+ Open-source 
+ Logiciel de gestion de version le plus utilis√© au monde.
:::

:::{.column}
![](images/git.png)
:::
::::

---

**Solutions utilisant Git**

::::{.columns}
:::{.column}
+ GitHub
+ GitLab
+ BitBucket
+ NPM
:::

:::{.column}
![](images/github.png)
:::
::::

---

### Le fonctionnement de Git

![](images/git-schematic.png)

---

### Un peu de jargon (1/2)


+ **clone** : Permet de "cloner", t√©l√©charger un d√©p√¥t (repository)
+ **fork** : Permet de copier un d√©p√¥t existant afin de le modifier sans affecter le d√©p√¥t initial.
+ **branche** : Dans la philosophie git, chaque fonctionnalit√© d'un projet est d√©velopp√©e sur une branche √† part. La branche principale, souvent appel√©e master, devrait toujours √™tre un projet en √©tat fonctionnel.
+ **commit** : Valider son travail sur le d√©p√¥t local. Est toujours associ√© √† une description.

---


### Un peu de jargon (2/2)

+ **push** : Mets √† jour le d√©p√¥t distant √† partir du d√©p√¥t local. (upload le dernier commit)
+ **pull** : Mets √† jour le d√©p√¥t local √† partir du d√©p√¥t distant. (t√©l√©charge le ou les derniers commit)
+ **pull request** : Demande la permission d'appliquer les modifications d'une branche de d√©veloppement sur la branche principale
+ **merge** : Fusionne une branche dans une autre

# TP : Configuration d'un environnement de travail

## √Ä faire

+ Installer [Github Desktop](https://desktop.github.com/)
+ Installer Git (devrait √™tre inclus dans Github Desktop)
+ Cr√©er un compte sur GitHub
+ "Forker" le repository suivant : [https://github.com/jpecquais/initiation-programmation-son](https://github.com/jpecquais/initiation-programmation-son)

# Introduction au langage lua

## G√©n√©ralit√©s

::::{.columns}
:::{.column}
+ Cr√©√© en 1993, au Br√©sil
+ Luiz Henrique de Figueiredo, Roberto Ierusalimschy et Waldemar Celes
+ Con√ßu afin d'√™tre embarqu√© au sein d'une autre application
+ Interpr√©teur en C, donc largement compatible
:::

:::{.column}
![](images/lua.png)
:::
::::

Tr√®s populaire dans le d√©veloppement de jeux vid√©o. Utilis√© √©galement dans le r√©seau et dans l'informatique embarqu√©e.

On le retrouve aussi dans les logiciels **REAPER** et **TouchOSC** dans le monde de l'audio.


## Les variables

Pour d√©clarer une variable, il suffit de lui donner un nom et une valeur.

```{lua}
foo = 3 --cr√©er une variable, nomm√©e "foo", stockant le nombre 3
```

Un ensemble de caract√®res pr√©c√©d√©s par "--" est consid√©r√© comme un commentaire.

La bonne pratique consiste √† toujours pr√©c√©der la d√©claration d'une variable par le mot-clef "local". Cela permet de limiter la zone de d√©finition de la variable.

```{lua}
local foo = 3
```

## Les types de variables

```{lua}
local myNumber  = 3                --cette variable est un nombre
local myString  = "Hello, World!"  --cette variable est une chaine de charact√®re (string)
local myBool    = true             --cette variable est un bool√©en
local myNil     = nil              --cette variable ne poss√®de aucune valeur
```

Le typage en lua est extr√™mement faible. Une variable peut changer de type a n'importe quel moment, sans contraintes.

```{lua}
local myNumber  = 3                --cette variable est un nombre
myNumber        = "Hello, World!"  --est-ce bien pertinent ?
```
---

## Les op√©rations

```{lua}
local a  = 3+2                      --addition
local b  = 5-7                      --soustraction
local c  = 2*5                      --multiplication
local d  = 10/2                     --division

local e  = "Hello,".." World!"      --concat√©nation
```

Il est √©galement possible d'appliquer des op√©rations sur des variables

```{lua}
local a = 2
local b = 8

local c = (a+b)/4
```


## Quelques fonctions

```{lua}
print("Hello, World!")              --Affiche la cha√Æne de charact√®res "Hello, World!" dans le terminal. Pratique pour d√©bugger.

local foo = tostring(3)
print(foo)                          --Affiche la cha√Æne de charact√®res "3" dans le terminal.

local bar = tonumber("3")           
print(bar)                          --Affiche le nombre 3 dans le terminal.

local myType = type(foo)            --La fonction type retourne une cha√Æne de charact√®re indiquant le type de la variable.
print(foo)                          -- Affiche la cha√Æne de charact√®res "number" dans le terminal
```

## Les conditions

```{lua}
local a = 3
local b = 2

local result = false

--Les symboles de comparaison sont == >= <= > < ~=
if a == b then
    result = true
end

print(result)
```

```{lua}
local a = 3
local b = 2

local myString = nil

if a >= b then
    myString == "This is true"
else
    myString == "This is false"
end

print(myString)
```

```{lua}

-- il est possible d'utiliser les mots clefs "and" et "or" pour indiquer des relations de condition plus complexes

if a and b then -- "if a" permet de v√©rifier si a n'est pas √©gal √† nil. Idem pour b.
    -- faire quelque chose
elseif a or b then
    -- faire autre chose
else
    -- choix par d√©faut
end

```

## Les boucles "for"

```{lua}
-- les boucles "for" permettent de boucler un m√©canisme tant qu'une variable n'atteint pas une certaine valeur.

for i=0, 10 do --incr√©ment de 0 √† 10 par pas de 1 (valeur par d√©faut)
    print(i)
end

for j=10, 0, -1 do --d√©cr√©ment de 10 √† 0 par pas de 1
    print(j)
end

for k=0, 10, 2 do --incr√©mente de 0 √† 10 par pas de 2
    print(k)
end

```

## Les fonctions

```{lua}

function myFunction(argument1) -- d√©finition de la fonction "myFunction" qui prend un argument "argument1"
    argument1 = argument1 + 1
    return argument1
end

local a = 2
a = myFunction(a) --appel de la fonction "myFunction"
print(a)

```

```{lua}

function isEven(input)
    if input % 2 == 0 then
        return true
    else
        return false
    end
end

local a = 2
print(isEven(a))

```

# TP - Scripting dans REAPER

## Afficher "Hello World" dans la console de REAPER

1. Trouver la fonction de REAPER permettant d'afficher un message dans la console. (print() ne fonctionne pas!)

## Compter le nombre de pistes dans la session et afficher ce nombre

1. Compter le nombre de pistes
2. Afficher ce nombre

## Afficher le nom des pistes s√©lectionn√©es dans la console

1. Compter le nombre de pistes s√©lectionn√©es
2. Pour chaque piste s√©lectionn√©e, obtenir son nom.
3. Afficher le nom dans le terminal.

## Cr√©er une fonction "print()"

But : cr√©er une fonction pour afficher n'importe n'importe quel type de variable dans la console de REAPER.

√âtapes :

+ Trouver la fonction "ShowConsoleMsg()" dans l'API de REAPER
+ Appeler la fonction "ShowConsoleMsg()" √† travers une fonction "print()" prenant la valeur √† afficher en argument
+ Attention au type de la valeur √† afficher !

## R√©initialiser tous les faders de la session √† 0 dB

1. Compter le nombre de pistes dans la session
2. Pour chaque piste, r√©initialiser le fader de niveau √† 0 dB

:::{.notes}
number reaper.SetMediaTrackInfo_Value(MediaTrack tr, string parmname)
:::

## Baisser le volume des pistes s√©lectionn√©es de 3 dB


## D√©placer les pistes s√©lectionn√©es dans une nouvelle piste dossier

√âtapes :

1. Trouver la fonction de l'API permettant de r√©organiser les pistes
2. Cr√©er une nouvelle piste
3. D√©placer les pistes s√©lectionn√©es comme filles de la piste cr√©√©e √† l'√©tape (2)

:::{.notes}
1. La fonction √† appeler est reaper.ReorderSelectedTracks(beforeTrackIdx, makePrevFolder)
2. Il faut obtenir la premi√®re piste de la s√©lection de pistes
3. Il faut obtenir l'index de la premi√®re piste s√©lectionn√©e
4. Il faut cr√©er une piste √† l'idx de la piste s√©l√©ctionn√©e-1
:::

```{lua}
local tr1 = reaper.GetSelectedTrack(0,0)
local tr1Idx = reaper.GetMediaTrackInfo_Value(tr1, "IP_TRACKNUMBER")
reaper.InsertTrackAtIndex(tr1Idx-1, true)
reaper.ReorderSelectedTracks(tr1Idx, 1)
```

---

## Afficher le timecode de d√©but et de fin des objets s√©lectionn√©s dans la console

---

## Couper l'objet sous le curseur de la souris au niveau du curseur de la souris

# FAUST

## K√©zako ?

+ [Langage de programmation](https://faust.grame.fr/) d√©di√© au traitement du signal audio.
+ Un seul type : tout est signal
+ D√©velopp√© au [GRAME](https://www.grame.fr/) (Lyon)
+ Permet de g√©n√©rer des externals Max/MSP, PureData, plug-ins audio (VST et AU).
+ N√©cessite peu de configuration gr√¢ce √† un [IDE en ligne](https://faustide.grame.fr/).

## Prise en main

+ Tutoriel [**Quick Start**](https://faustdoc.grame.fr/manual/quick-start/) sur le site de Faust
+ [Documentation](https://faustdoc.grame.fr/) du langage.
+ [Librairie](https://faustlibraries.grame.fr/) disponible.

# TP FAUST

## Contr√¥le de volume

+ Cr√©er un simple slider, permettant d'amplifier le signal sur une plage allant de -inf √† +6dB (l'affichage pourra montrer les valeurs lin√©aires pour commencer).

:::{.notes}
```{faust}
import("stdfaust.lib");
process = no.noise*(vslider("Gain",1,0,2,0.01):si.smoo);
```
:::

## Panner

+ On veut un r√©glage pour panner le signal en entr√©e (mono ou st√©r√©o) 
+ On peut penser √† un syst√®me √† deux contr√¥les de volume, un pour le canal 1 et un pour le canal 2, pilot√© par le m√™me r√©glage

:::{.notes}
```{faust}
import("stdfaust.lib");

pi = 22/7;
phi = (pi/2)*(hslider("Pan",0,-100,100,0.1)+100)/200;
process = no.noise<:((*(cos(phi))),(*(sin(phi))));
```
:::

## Clipper

+ En analogique, "clipper" c'est quand la tension du signal d'entr√©e exc√®de la tension d'alimentation.
+ En num√©rique, "clipper" c'est d√©passer le 0 dBFS (en 24bit). En lin√©aire, un √©chantillon "clip" quand sa valeur d√©passe 1.
+ Nous pouvons donc imaginer un syst√®me de seuil. Lorsque le signal en entr√©e d√©passe le seuil, on retourne la valeur du seuil.
+ **Attention, il faut traiter les alternances positives et n√©gatives**

:::{.notes}
```{faust}
import("stdfaust.lib");

thresh = pow(10,hslider("Threshold", 0, -30, 6, 0.1)/20);

process = os.osc(440)<:(
    ba.if(>(thresh),(thresh),_)<:
    ba.if(<(-thresh),(-thresh))
    );
```
:::

## Tremolo

+ Un tr√©molo permet de moduler l'intensit√© sonore d'une source en fonction d'un g√©n√©rateur basse fr√©quence "LFO" (que l'on choisira sinuso√Ødal).
+ **Attention √† la plage de valeurs prise par une sinuso√Øde.**
+ Bonus : comment pourrait-on diff√©rencier le traitement du canal gauche du canal droit, avec une notion de largeur "st√©r√©ophonique" ?
+ Bonus 2 : Que se passe-t-il, pour un son pur, si la fr√©quence du LFO d√©passe 20 Hz et plus ? Et pour un signal plus complexe ?

:::{.notes}
```{faust}
import("stdfaust.lib");

pi = 22/7;
amount = hslider("Amount", 50,0,100,1)/100;
freq = hslider("LFO Freq.", 4, 1, 200, 0.1);
phi = pi*hslider("Width", 0, 0, 180, 1)/180;


sinOsc(f,phi)=(os.oscp(f,phi)+1)/2;

process = os.osc(440)<:(
    *(sinOsc(freq,0)*amount+(1-amount)),
    *(sinOsc(freq,phi)*amount+(1-amount))
);
```
:::

## D√©lai de remise en phase

+ On utilise la primitive @(N), ou N correspond au retard en √©chantillons

## Delay & co.

+ Cr√©er un circuit de m√©lange entre le son direct et un signal retard√©.
+ Cr√©er une boucle de r√©injection du signal retard√© sur lui-m√™me.
+ Filtrer le signal de la r√©p√©tition (passe-bas et passe-haut)
+ Moduler le signal de la r√©p√©tition

## Egaliseur

+ Utiliser les fonctions de la librairie standard de FAUST pour cr√©er un √©galiseur comprenant :
    + Une bande shelf grave
    + Une bande shelf aigu√´
    + Trois bandes param√©triques m√©diums

```{faust}
import("stdfaust.lib");
filterBank(N) = hgroup("[2]Filter Bank",seq(i,N,oneBand(i)))
with {
    oneBand(j) = vgroup("[%j]Band %a",fi.peak_eq(l,f,b))
    with {
        a = j+1; // just so that band numbers don't start at 0
        l = vslider("[2]Level[unit:db]",0,-24,24,0.01) : si.smoo;
        f = hslider("[1]Freq[style:knob][scale:log]",320*(pow(10,j/2.5)),20,20000,0.01) : si.smoo;
        b = f/hslider("[0]Q[style:knob][scale:log]",0.3,0.1,30,0.01) : si.smoo;
    };
};
nBands = 3;

lowShelf = hgroup("[1]Low shelf", fi.low_shelf(Ll,fl))
with{
    Ll = vslider("[1]Level[unit:db]",0,-27,12, 0.01):si.smoo;
    fl = vslider("[0]Freq[scale:log][style:knob]",180,20,800, 0.01):si.smoo;
};

highShelf = hgroup("[3]High shelf", fi.high_shelf(Lh,fh))
with{
    Lh = vslider("[1]Level[unit:db]",0,-27,12, 0.01):si.smoo;
    fh = vslider("[0]Freq[scale:log][style:knob]",3800,800,20000, 0.01):si.smoo;
};


process = hgroup("My EQ", lowShelf : filterBank(nBands) : highShelf);
```

## TP - Conception d'un compresseur

+ Comment fonctionne un compresseur ?
+ Quels sont ses r√©glages ?
+ Comment les impl√©menter ?

## Pour finir : compiler un plug-in VST

+ Utiliser la fonction **export** de l'IDE en ligne.
+ Installer **Visual Studio** sous Windows ou **XCode** sous macOS.
+ G√©n√©rer le projet depuis l'interface Projucer de **Juce**