---
title: Initiation √† la programmation
subtitle: Et son application aux m√©tiers du son
author: Jean-Loup Pecquais
format:
    revealjs:
        theme: simple
        highlight-style: github
        scrollable: true
---

# Programme

## Jours 1

+ Rappels sur l'informatique d√©di√©e √† l'audio temps r√©el
+ Les environnements de d√©veloppement et les m√©thodes de travail
+ Introduction au langage lua
+ D√©couverte de l'API de ReaScript
+ TP : Cr√©ation de scripts (1/2)

## Jours 2

+ TP : Cr√©ation de scripts (2/2)
+ Pr√©sentation du langage de programmation FAUST
+ TP : Cr√©er un plug-in audio

## Jours 3

+ TP : Cr√©ation d'un compresseur
+ Cr√©ation d'un plug-in VST3 (?)

## Objectifs

+ D√©couvrir le monde de la programmation
+ Ajouter la programmation dans sa boite √† outils d'ing√©nieur du son
+ Comprendre les tenants et les aboutissants de la cr√©ation d'un plug-in audio

## Contact

+ Jean-Loup Pecquais
+ ```jeanlouppecquais@ik.me```


# Pr√©ambule

## Pourquoi s'int√©resser √† la programmation ?

:::{.incremental}
+ Comprendre le fonctionnement de ses outils
+ Pouvoir adapter et/ou construire ses outils
+ Mieux investir son temps et son argent ?
:::

# G√©n√©ralit√©s

:::{.notes}
+ Qu'est-ce qu'un ordinateur ?
+ Qu'est-ce qu'un langage de programmation ?
:::

## Les ordinateurs

+ Ensemble de composants : Processeurs + M√©moires
    + Processeurs : CPU (plusieurs c≈ìurs ou plusieurs CPU), GPU
    + M√©moire de stockage, m√©moire vive, etc.

+ Ensemble de logiciels
    + Kernel
    + Gestion des p√©riph√©riques (audio, vid√©o, contr√¥leurs)
    + Interfaces graphiques (bureau, explorateur de fichiers)

## Les syst√®mes d'exploitation

::::{.columns}

:::{.column}

**Solutions propri√©taires**

:::{layout-ncol="2"}
![](images/windows.jpg){width="50%"}

![](images/macos.png)
:::

+ Windows (Microsoft)
+ MacOS (Apple)

:::

:::{.column}

**Solutions libres**

![](images/linux.png){width="50%"}

+ Linux/GNU (Libre et gratuit)

:::

::::

---

**Choisir son OS ?**

:::{.incremental}
+ MacOS : Linux clef en main
+ Linux : MacOS en kit
+ Windows : ü§∑‚Äç‚ôÇÔ∏è
:::

---

## Informatique embarqu√©e / informatique g√©n√©raliste

::::{.columns}

:::{.column}
Informatique embarqu√©e

+ Optimis√© pour une t√¢che (exemple : console de mixage num√©rique)
:::

:::{.column}
Informatique de "bureau"

+ Polyvalente, mais non sp√©cifique
:::

::::

On peut √©galement √©voquer l'informatique destin√©e aux serveurs.

---

## Les d√©fis de l'audionum√©rique sur ordinateur g√©n√©rique

+ **Le traitement de l'audio en temps r√©el !**

    + Equipement non d√©di√© (donc non optimis√©)
    + Tous les kernels ne sont pas √©gaux.
    + Toutes les bus de communication ne se vallent pas (USB vs PCIe par ex.)
    + Tous les pilotes d'interfaces audio non plus.
    + Ainsi que les logiciels ( Pro Tools & REAPER par ex. ;-) ) 

:::{.notes}
Kernels : "noyau" // G√©n√©rique VS low-latency VS real-time // diff√©rences de scheduler et de gestion des priorit√©s. // FIFO - LILO - FILO etc.
:::

## Les d√©fis du d√©veloppement orient√© audio

Au-del√† de la qualit√© sonore d'un plug-in

+ Optimiser les ressources (CPU / RAM)
+ Prendre le minimum de temps possible

Dans les deux cas, la question est souvent : √† quel prix sur le rendu sonore ?

---

### Exemple concret : √©galiseur {.smaller}

::::{.columns}

:::{.column}
**ReaEQ (Cockos)**

![](images/reaeq.jpg)

+ **temps r√©el**
+ Cramping vers la fr√©quence de Nyquist.

:::

:::{.column}
**Pro-Q3 (Fab Filter)** :

![](images/proq3.jpg)

+ *z√©ro latence* : **temps r√©el**, sans cramping. D√©phasage du filtre se replie √† Nyquist.
+ *natural phase* : **320 smpl** de latence, plus de cramping
+ *phase lin√©aire* : de **3072 smpl** √† **66560 smpl**, inutilisable pour du temps r√©el.
:::

::::

--- 

### Exemple concret : compresseur

::::{.columns}

:::{.column}
**ReaComp (Cockos)**

![](images/reacomp.png)

+ **Temps r√©el**
+ **Repliement spectral** (aliasing) lorsque les temps d'attaque et de rel√¢chement sont courts.
:::

:::{.column}
**Molotok (Tokyo Dawn Lab)**

![](images/molotok.jpg)

+ Plusieurs modes permettant d'ajuster le ratio latence/performance audio.
+ **"Alias"** en mode **temps r√©el**.
+ Les modes *√©co* et *precise* utilisent certainement du sur√©chantillonnage pour r√©duire le repliement spectral.
:::

::::

---

### Exemple concret : saturation

::::{.columns}

:::{.column}
**Saturation (LOSER)**

![](images/saturation.png)

+ temps r√©el
+ Forte pr√©sence d'alisaing
+ L√©ger en ressource.
:::

:::{.column}
**ChowTapeModel (ChowDSP)**

![](images/chowtapemodel.png)

+ Latence de 36 smpl par d√©faut.
+ Jusqu'√† 102 smpl de latence √† OS*16 en phase lin√©aire.
+ Tr√®s gourmand en ressource, mais rendu "qualitatif".
:::

:::::

## Les qualit√©s d'un plug-in

:::{.incremental}
+ Chercher le meilleur rapport entre performance et qualit√© de rendu sonore
+ Stabilit√© sur les diff√©rents formats (VST, VST3, AAX, AU, LV2, etc.)
+ **Et l'interface utilisateur !**
:::

# La programmation et ses langages

## Que signifie "programmer"

:::{.incremental}
+ Donner des instructions au processeur.
+ Pour cela on utilise un langage.
+ L'utilisation d'un langage plut√¥t qu'un autre viendra d√©finir un √©quilibre entre performance, fonctionnalit√©s, et facilit√© de d√©veloppement.
:::

## Les diff√©rents types de langages

Du niveau le plus bas au plus haut (du plus proche de la machine au plus proche de l'utilisateur)

:::{.incremental}
+ Le langage assembleur
+ Les langages compil√©s
+ Les langages interpr√©t√©s
:::

## Hello world en assembleur !

En assembleur :

```{assembly}
str:
 .ascii "Hello World!\n"
 .global _start

_start:
movl $4, %eax
movl $1, %ebx
movl $str, %ecx
movl $8, %edx
int $0x80
movl $1, %eax
movl $0, %ebx
int $0x80

;Compilation:
;as code.s -o code.o
;ld code.o -o code

;Execution:
;./code
```

## Hello world en C++ !

En C++ :

```{c++}
#include <iostream>
using namespace std;
int main() {
   cout << "Hello World!" << endl; // This prints Hello, World!
   return 0;
}
```

## Hello world en lua !

```{lua}
print("Hello World!")
```

---

### Les langages compil√©s vs langages interpr√©t√©s

::::{.columns}
:::{.column}
![](images/compiler.png){width="38%"}
:::

:::{.column}
![](images/interpreter.png){width="38%"}
:::
::::

:::{.notes}
D√©monstration de la compilation et de l'utilisation d'un logiciel
:::

## Langages √† "conna√Ætre"

:::{.r-fit-text}
Le **C** (1972), d√©velopp√© par Dennis Ritchie et Kenneth Thompson, aux laboratoires Bell.

+ **C++** (1983, repr√©sente la majorit√© des applications informatiques)
+ **Lua** (REAPER, TouchOSC)
+ **JavaScript** (MaxMSP, Open Stage Control, Chata√Ægne)
+ **Faust** (D√©veloppement DSP facilit√©)
+ **Python** (Bo√Æte √† outils extr√™mement compl√®te, alternative √† Mathlab)
+ Pour le dsp: **Octave**, **Julia**, etc.

Autre:

+ **Java** : Android
+ **JavaScript** : Web en g√©n√©ral

En sus (m√™me si ce ne sont pas des languages de programmation):

+ **Markdown** (prise de note, cr√©ation de documents, pages web)
+ **Quarto** (alternative √† LaTeK / HTML)
:::

:::{.notes}
Conna√Ætre dans le sens : conna√Ætre son existence. Il ne s'agit pas d'apprendre tous ces langages.
:::

# Les outils de d√©veloppement

## Les IDE

### Qu'est-ce qu'un IDE ?

:::{.incremental}
+ Environnement de d√©veloppement int√©gr√©
+ Regroupe un ensemble de fonctionnalit√©s :
    * Un √©diteur de texte
    * Une aide √† l'√©criture (auto-compl√©tion)
    * Un terminal
    * Un compileur / un interpr√©teur
    * Un gestionnaire de projet
:::

---

**Quelques exemples**

::::{.columns}

:::{.column}
+ Les classiques
    * Visual Studio
    * X-Code
    * CodeBlock
:::

:::{.column}
+ Les plus "modernes"
    * Visual Studio Code
    * Sublime text
    * PyCharm/Clion/JetBrain
:::

::::

## Les frameworks

### Le principe

+ Proposer un socle de fonctionnalit√©s de base :
    * Accesseur audio, une librairie graphique, blocs DSP √©l√©mentaires, etc.

**Quelques exemples**

::::{.columns}
:::{.column}
**JUCE**

+ Utilis√© par la grande majorit√© des plug-ins du march√©
+ Appartiens √† PACES
+ Soutenu par une grande communaut√©
:::

:::{.column}
**FLUX:: Framework**

+ Tr√®s complet et tr√®s puissant
+ R√©serv√© √† la soci√©t√© FLUX::
+ Tr√®s peu d'utilisation en dehors des produits FLUX::
:::
::::
**Waves**, **UAD**, **MeldaProduction**, sont des exemples de marques utilisant leur **propre** framework.

## Les SDK

### Pr√©sentation

+ SDK signifie : Software Development Kit
+ Outil d√©livr√© √† des d√©veloppeurs par des d√©veloppeurs

### Exemples

+ SDK VST3 de Steinberg
+ SDK AAX de Pro Tools


## Les API

### Pr√©sentation

+ API signifie : Application Programming Interface
+ Ensemble de classes, m√©thodes, fonctions et variable
+ Permets √† deux logiciels de s'interfacer

### Exemples

+ L'API ReaScript de REAPER
+ L'API Javascript de MaxMSP

## Les librairies

### Pr√©sentation

+ Ensemble de fonctions d√©di√©es √† une t√¢che particuli√®re

### Exemples

+ Matplotlib pour le trac√© de graphique sous python

# Les logiciels de gestion de version

## Travail collaboratif

+ Le d√©veloppement est un travail d'√©quipe
    + Architecte logiciel
    + Impl√©mentation bas niveau, framework
    + Impl√©mentation DSP
    + Impl√©mentation graphique
    + etc.
+ Plusieurs personnes peuvent √™tre amen√©es √† manipuler les m√™mes fichiers
+ Certaines modifications peuvent casser le programme, comment revenir en arri√®re ?

## Git

::::{.columns}
:::{.column}
+ Cr√©√© par Linus Torvald
+ Open-source 
+ Logiciel de gestion de version le plus utilis√© au monde.
:::

:::{.column}
![](images/git.png)
:::
::::

---

**Solutions utilisant Git**

::::{.columns}
:::{.column}
+ GitHub
+ GitLab
+ BitBucket
+ NPM
:::

:::{.column}
![](images/github.png)
:::
::::

---

### Le fonctionnement de Git

![](images/git-schematic.png)

---

### Un peu de jargon (1/2)


+ **clone** : Permet de "cloner", t√©l√©charger un d√©p√¥t (repository)
+ **fork** : Permets de copier un d√©p√¥t existant afin de le modifier sans affecter le d√©p√¥t initial.
+ **branche** : Dans la philosophie git, chaque fonctionnalit√© d'un projet est d√©velopp√©e sur une branche √† part. La branche principale, souvent appel√©e master, devrait toujours un projet en √©tat fonctionnel.
+ **commit** : Valider son travail sur le d√©p√¥t local. Est toujours associ√© √† une description.

---


### Un peu de jargon (2/2)

+ **push** : Mets √† jour le d√©p√¥t distant √† partir du d√©p√¥t local. (upload le dernier commit)
+ **pull** : Mets √† jour le d√©p√¥t local √† partir du d√©p√¥t distant. (t√©l√©charge le ou les derniers commit)
+ **pull request** : Demande la permission d'appliquer les modifications d'une branche de d√©veloppement sur la branche principale
+ **merge** : Fusionne une branche dans une autre

# TP : Configuration d'un environnement de travail

## √Ä faire

+ Installer [Github Desktop](https://desktop.github.com/)
+ Installer Git (devrait √™tre inclus dans Github Desktop)
+ Cr√©er un compte sur GitHub
+ "Forker" le repository suivant : [https://github.com/jpecquais/ENSLL-Dev101-2022](https://github.com/jpecquais/ENSLL-Dev101-2022) <!-- edit repo !!!! -->

# Introduction au langage lua

## G√©n√©ralit√©s

::::{.columns}
:::{.column}
+ Cr√©√© en 1993, au Br√©sil
+ Luiz Henrique de Figueiredo, Roberto Ierusalimschy et Waldemar Celes
+ Con√ßu afin d'√™tre embarqu√© au sein d'une autre application
+ Interpr√©teur en C, donc largement compatible
:::

:::{.column}
![](images/lua.png)
:::
::::

Tr√®s populaire dans le d√©veloppement de jeux vid√©os. Utilis√© √©galement dans le r√©seau et dans l'informatique embarqu√©e.

On le retrouve aussi dans les logiciels **REAPER** et **TouchOSC** dans le monde de l'audio.


## Les variables

Pour d√©clarer une variable, il suffit de lui donner un nom et une valeur.

```{lua}
foo = 3 --cr√©er une variable, nomm√©e "foo", stockant le nombre 3
```

Un ensemble de caract√®res pr√©c√©d√©s par "--" est consid√©r√© comme un commentaire.

La bonne pratique consiste √† toujours pr√©c√©der la d√©claration d'une variable par le mot-clef "local". Cela permet de limiter la zone de d√©finition de la variable.

```{lua}
local foo = 3
```

## Les types de variables

```{lua}
local myNumber  = 3                --cette variable est un nombre
local myString  = "Hello, World!"  --cette variable est une chaine de charact√®re (string)
local myBool    = true             --cette variable est un bool√©en
local myNil     = nil              --cette variable ne poss√®de aucune valeur
```

Le typage en lua est extr√™mement faible. Une variable peut changer de type a n'importe quel moment, sans contraintes.

```{lua}
local myNumber  = 3                --cette variable est un nombre
myNumber        = "Hello, World!"  --est-ce bien pertinent ?
```
---

## Les op√©rations

```{lua}
local a  = 3+2                      --addition
local b  = 5-7                      --soustraction
local c  = 2*5                      --multiplication
local d  = 10/2                     --division

local e  = "Hello,".." World!"      --concat√©nation
```

Il est √©galement possible d'appliquer des op√©rations sur des variables

```{lua}
local a = 2
local b = 8

local c = (a+b)/4
```


## Quelques fonctions

```{lua}
print("Hello, World!")              --Affiche la cha√Æne de charact√®res "Hello, World!" dans le terminal. Pratique pour d√©bugger.

local foo = tostring(3)
print(foo)                          --Affiche la cha√Æne de charact√®res "3" dans le terminal.

local bar = tonumber("3")           
print(bar)                          --Affiche le nombre 3 dans le terminal.

local myType = type(foo)            --La fonction type retourne une cha√Æne de charact√®re indiquant le type de la variable.
print(foo)                          -- Affiche la cha√Æne de charact√®res "number" dans le terminal
```

## Les conditions

```{lua}
local a = 3
local b = 2

local result = false

--Les symboles de comparaison sont == >= <= > < ~=
if a == b then
    result = true
end

print(result)
```

```{lua}
local a = 3
local b = 2

local myString = nil

if a >= b then
    myString == "This is true"
else
    myString == "This is false"
end

print(myString)
```

```{lua}

-- il est possible d'utiliser les mots clefs "and" et "or" pour indiquer des relations de condition plus complexes

if a and b then -- "if a" permet de v√©rifier si a n'est pas √©gal √† nil. Idem pour b.
    -- faire quelque chose
elseif a or b then
    -- faire autre chose
else
    -- choix par d√©faut
end

```

## Les boucles "for"

```{lua}
-- les boucles "for" permettent de boucler un m√©canisme tant qu'une variable n'atteint pas une certaine valeur.

for i=0, 10 do --incr√©ment de 0 √† 10 par pas de 1 (valeur par d√©faut)
    print(i)
end

for j=10, 0, -1 do --d√©cr√©ment de 10 √† 0 par pas de 1
    print(j)
end

for k=0, 10, 2 do --incr√©mente de 0 √† 10 par pas de 2
    print(k)
end

```

## Les fonctions

```{lua}

function myFunction(argument1) -- d√©finition de la fonction "myFunction" qui prend un argument "argument1"
    argument1 = argument1 + 1
    return argument1
end

local a = 2
a = myFunction(a) --appel de la fonction "myFunction"
print(a)

```

```{lua}

function isEven(input)
    if input % 2 == 0 then
        return true
    else
        return false
    end
end

local a = 2
print(isEven(a))

```

# TP - Scripting dans REAPER

## Afficher "Hello World" dans la console de REAPER

1. Trouver la fonction de REAPER permettant d'afficher un message dans la console. (print() ne fonctionne pas!)

## Compter le nombre de pistes dans la session et afficher ce nombre

1. Compter le nombre de pistes
2. Afficher ce nombre

## Afficher le nom des pistes s√©lectionn√©es dans la console

1. Compter le nombre de pistes s√©lectionn√©es
2. Pour chaque piste s√©lectionn√©e, obtenir son nom.
3. Afficher le nom dans le terminal.

## Cr√©er une fonction "print()"

But : cr√©er une fonction pour afficher n'importe n'importe quel type de variable dans la console de REAPER.

Etapes :

+ Touver la fonction "ShowConsoleMsg()" dans l'API de REAPER
+ Appeler la fonction "ShowConsoleMsg()" √† travers une fonction "print()" prenant la valeur √† afficher en argument
+ Attention au type de la valeur √† afficher !

## R√©initialiser tous les faders de la session √† 0 dB

1. Compter le nombre de pistes dans la session
2. Pour chaque piste, r√©initialiser le fader de niveau √† 0 dB

:::{.notes}
number reaper.SetMediaTrackInfo_Value(MediaTrack tr, string parmname)
:::

## Baisser le volume des pistes s√©lectionn√©es de 3 dB


## D√©placer les pistes s√©lectionn√©es dans une nouvelle piste dossier

Etapes :

1. Trouver la fonction de l'API permettant de r√©organiser les pistes
2. Cr√©er une nouvelle piste
3. D√©placer les pistes s√©lectionn√©es comme filles de la piste cr√©√©e √† l'√©tape (2)

:::{.notes}
1. La fonction √† appeler est reaper.ReorderSelectedTracks(beforeTrackIdx, makePrevFolder)
2. Il faut obtenir la premi√®re piste de la s√©lection de pistes
3. Il faut obtenir l'index de la premi√®re piste s√©lectionn√©e
4. Il faut cr√©er une piste √† l'idx de la piste s√©l√©ctionn√©e-1
:::

```{lua}
local tr1 = reaper.GetSelectedTrack(0,0)
local tr1Idx = reaper.GetMediaTrackInfo_Value(tr1, "IP_TRACKNUMBER")
reaper.InsertTrackAtIndex(tr1Idx-1, true)
reaper.ReorderSelectedTracks(tr1Idx, 1)
```

---

## Afficher le timecode de d√©but et de fin des objets s√©lectionn√©s dans la console

---

## Couper l'objet sous le curseur de la souris au niveau du curseur de la souris

# FAUST

## K√©zako ?

# TP JSFX

## Contr√¥le de volume (1/2)

## Panner

+ On veut un r√©glage pour panner le signal en entr√© (mono ou st√©r√©o) 
+ On peut penser √† un syst√®me √† deux contr√¥les de volume, un pour le canal 1 et un pour le canal 2, pilot√© par le m√™me r√©glage

## Clipper

+ En analogique, "clipper" c'est quand la tension du signal d'entr√© exc√®de la tension d'alimentation.
+ En num√©rique, "clipper" c'est d√©passer le 0 dBFS en 24bit. En lin√©aire, un √©chantillon "clip" quand sa valeur d√©passe 1.
+ Nous pouvons donc imaginer un syst√®me de seuil. Lorsque le signal en entr√© d√©passe le seuil, on retourne la valeur du seuil.

## Tremolo

+ Un tr√©molo permet de moduler l'intensit√© sonore d'une source en fonction d'un g√©n√©rateur basse fr√©quence "LFO"
+ Une impl√©mentation simple d'un LFO peut se faire √† travers une fonction sinus (ou cosinus). $y = sin(2\pi \times f+\phi)$ . Rappelons ici que la fr√©quence est √©gale √† l'inverse de la p√©riode. La p√©riode √©tant un temps, il est possible de l'exprimer en √©chantillon.
+ Bonus : comment pourrait-on diff√©rencier le traitement du canal gauche du canal droit, avec une notion de largeur st√©r√©ophonique ?
+ Bonus 2 : Que se passe t-il, pour un son pur, si la fr√©quence du LFO d√©passe 20 Hz et plus ?

## D√©lai de remise en phase

+ Pour retard un signal, il faut l'enregistrer, puis le relire en temps diff√©r√©.
+ Il faut donc :
    + Une m√©moire tampon (buffer), qui prendra la forme d'un tableau dans lequel on stockera des donn√©es.
    + Une t√™te d'enregistrement et une t√™te de lecture, qui prendront la forme de deux variables qui seront incr√©ment√©es √† chaque nouvel √©chantillon.
    + La diff√©rence entre les valeurs des deux t√™tes de lecture correspondra au d√©lai de relecture.
    + Le temps de d√©lai sera exprim√© en √©chantillons pour l'utilisateur.

## Sujet libre !

Quelques propositions :

+ Un pan en gain et d√©lai
+ Un chorus
+ Un flanger
+ Un looper
+ Un √©cho
